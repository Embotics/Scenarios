{
  "id": "",
  "guid": "",
  "name": "Restore Snapshot",
  "description": null,
  "type": "CHANGE_COMPLETION",
  "change_description": null,
  "target_type": null,
  "input_variables": [],
  "info_messages": [],
  "system_version": "8.7.1 (1007120055)",
  "steps": [
    {
      "name": "AWS Restore",
      "type": "EMBEDDED_SCRIPT",
      "condition": "#{target.cloudAccount.type} -eq \"amazon_aws\"",
      "data": {
        "credentials": null,
        "failure_action": "FAIL_STEP",
        "script_contents": "<#\nAWS Restore Snapshot\nRequires AWS module - \"AWSPowershell.netcore\"\n#>\n\n$accessKey = (Get-Item Env:AWS_ACCESS_KEY_ID).value\n$secretKey = (Get-Item Env:AWS_SECRET_ACCESS_KEY).value\n$instanceId = \"#{target.remoteId}\"\n$region = \"#{target.region.name}\"\n$requestId = \"#{request.id}\"\n\n#Check if credentials were supplied\nif(!($accesskey) -or !($secretKey) -or !($instanceID)){\n        Write-error \"Please provide AWS Login information\"\n        Exit 1\n        } \n#Remove white space for older versions of powershell\n$accesskey = $accesskey -replace \"\\s\", \"\"\n$secretKey = $secretKey -replace \"\\s\", \"\"\n\n#Import PS module\n$module = \"AWSPowershell.netcore\"\nif (Get-Module -ListAvailable -Name $module) {\n    Import-Module $module\n    Write-Debug \"Module $module is installed.\"\n} \nelse {\n    Write-Error \"Module $module does not appear to be installed, Please install and run again.\"\n    Exit 2\n}\n\n#Initialize credentials\nSet-AWSCredentials -AccessKey $accessKey -SecretKey $secretKey -StoreAs SnowCommander \nInitialize-AWSDefaults -ProfileName SnowCommander\n#Use provided region as default\nSet-DefaultAWSRegion -Region $region\n\n#Check if instance exists\nif (!(Get-EC2Instance -InstanceId $instanceId)) {\n\tWrite-Error \"Could not find EC2 Instance $instanceId\"\n\tExit 3\n}\n\n#Check if snapshots exist for this request\nif (!(Get-EC2Snapshot | ? { $_.Tags.Count -gt 0 -and $_.Tags.Key -eq \"Commander Request ID\" -and $_.Tags.Value -eq $requestId })) {\n\tWrite-Error \"Could not find snapshots for request $requestId\"\n\tExit 4\n}\n\n#Get snapshot data\n$snapshotList = Get-EC2Snapshot | ? { $_.Tags.Count -gt 0 -and $_.Tags.Key -eq \"Commander Request ID\" -and $_.Tags.Value -eq $requestId }\n\n#Get availability zone\n$instance = (Get-EC2Instance -Instance $instanceId).Instances\n$availabilityZone = $instance.Placement.AvailabilityZone\n\n#Stop instance before taking snapshot per AWS recommendation   \nStop-EC2Instance -Instance $instanceId > $null\n#Wait for instance to fully stop\ndo {\n    Sleep -Seconds 5\n    $instance = (Get-EC2Instance -Instance $instanceId).Instances\n}\nuntil($instance.State.Name -eq \"stopped\")\n\n#Get all volumes that have a snapshot, get its device name and dismount it from instance\n$oldVolumeIDs = @()\n$deviceList = @()\nforeach ($snapshot in $snapshotList) {\n    #Save volume id for later\n    Write-Debug \"Inserting volume id\" $snapshot.VolumeId\n    $oldVolumeIDs += @($snapshot.VolumeId)\n\n    #Create filter\n    $filter = New-Object Amazon.EC2.Model.Filter\n    $filter.Name = \"attachment.instance-id\"\n    $filter.Values = $instanceID\n    $filters = @($filter)\n    $filter = new-object Amazon.EC2.Model.Filter\n    $filter.Name = 'volume-id'\n    $filter.Values = $snapshot.VolumeId\n    $filters += @($filter)\n    #Get Device\n    Write-Host \"Getting device for volume\" $snapshot.VolumeId\n    $device = Get-EC2Volume -Filter $filters\n    if (!$device) {\n        Write-Error \"A snapshot is reffering to a volume that is no longer attached to a device. Please reattach the volume id $($snapshot.VolumeId) or delete the conflicting snapshot for this request id $requestId\"\n        Exit 6\n    }\n    $deviceList += @($device.Attachments[0].Device)\n\n    #Dismount volume\n    Write-Host \"Dimounting volume\" $snapshot.VolumeId \"from instance\" $instanceId\n    Dismount-EC2Volume -InstanceId $instanceId -VolumeId $snapshot.VolumeId >$null\n    #Wait so volume can be fully detached before trying to attach a new one\n    Sleep -Seconds 5\n}\n\n#Restore snapshots\n$volumeIDs = @()\nWrite-Host \"Restoring $($snapshotList.Length) snapshots\"\nfor ($i = 0; $i -lt $snapshotList.Length; $i++) {\n\n    #Create a new volume from snapshot\n    $volume = New-EC2Volume -SnapshotId $snapshotList[$i].SnapshotId -AvailabilityZone $availabilityZone\n    #Wait for the new volume to be ready\n    do {\n        Sleep -Seconds 5\n        $volumeState = (Get-EC2Volume -VolumeId $volume.VolumeId).State\n    }\n    until($volumeState -eq \"available\")\n    #store the volume ID\n    $volumeIDs += @($volume.VolumeId)\n    #Attach volume to instance\n    Write-Host \"Attaching volume\" $volume.VolumeId \"for device\" $deviceList[$i] \"from snapshot\" $snapshotList[$i].SnapshotId \"to instance\" $instanceId\n    Add-EC2Volume -InstanceId $instanceId -VolumeId $volume.VolumeId -Device $deviceList[$i] > $null\n}\n\n#Check if volumes were successfully mounted to the instance\n$instance = (Get-EC2Instance -Instance $instanceID).Instances\nif (!$instance.BlockDeviceMappings) {\n\tWrite-Error \"No volume attached to instance\" $instanceID\n\n    #Delete newly created volumes as we don~t know if they are good or not\n    foreach ($volume in $volumeIDs) {\n    Write-Host \"Removing volume\" $volume\n        Remove-EC2Volume -VolumeId $volume -Force\n    }\n    \n    #Mount old volumes and exit\n    for ($i = 0; $i -lt $oldVolumeIDs.Length; $i++) {\n        Write-Host \"Attaching volume\" $oldVolumeIDs[$i] \"with device id\" $deviceList[$i] \"to instance\" $instanceID\n        Add-EC2Volume -InstanceId $instanceID -VolumeId $oldVolumeIDs[$i] -Device $deviceList[$i]\n    }\n\tExit 5\n}\n\nWrite-Host \"Restore Completed\"\n#Start instance\nStart-EC2Instance -InstanceId $InstanceId > $null\n#Wait for instance to fully start\ndo {\n    Sleep -Seconds 5\n    $instance = (Get-EC2Instance -Instance $instanceId).Instances\n}\nuntil($instance.State.Name -eq \"running\")\n\n#Delete old volumes as we don~t need them anymore\nforeach ($volume in $oldVolumeIDs) {\nWrite-Host \"Removing volume\" $volume\n    Remove-EC2Volume -VolumeId $volume -Force\n}",
        "script_arguments": "",
        "timeout": 300,
        "executable": "powershell.exe",
        "capture_output": true
      }
    },
    {
      "name": "Azure Restore",
      "type": "EMBEDDED_SCRIPT",
      "condition": "#{target.cloudAccount.type} -eq \"ms_arm\"",
      "data": {
        "credentials": null,
        "failure_action": "FAIL_STEP",
        "script_contents": "<#\nAzure Instance restore Snapshot.\nRequires PS module AZ on the Commander server.\n*Commander 8.6.0 or higher\n*Advanced property \"embotics.workflow.script.credentials\" must be set to \"true\"\n#> \n\n$subscriptionId = (Get-Item Env:AZURE_SUBSCRIPTION_ID).value\n$tenantId = (Get-Item Env:AZURE_TENANT_ID).value\n$apiKey = (Get-Item Env:AZURE_API_KEY).value\n$applicationId = (Get-Item Env:AZURE_APPLICATION_ID).value\n$instanceId = \"#{target.remoteId}\"\n$resourceGroup = \"#{target.resourceGroup.name}\"\n$requestId = \"#{request.id}\"\n$module = \"AZ\"\n\nif(!($subscriptionId) -or !($tenantId) -or !($apiKey) -or !($applicationId)-or !($module) -or !($instanceId) -or  !($resourceGroup)){\n        Write-error \"Please provide Azure Login information\"\n        Exit 1\n}\n\n#Remove white space for older versions of powershell\n$subscriptionId = $subscriptionId -replace \"\\s\", \"\"\n$tenantId = $tenantId -replace \"\\s\", \"\"\n$apiKey = $apiKey -replace \"\\s\", \"\"\n$applicationId = $applicationId -replace \"\\s\", \"\" \n\n#Check for Module\nif (Get-Module -ListAvailable -Name \"$module.*\") {\n    Import-Module $module\n    Write-Debug \"Module $module is installed.\"\n} \nelse {\n    Write-Error \"Module $module does not appear to be installed, Please install and run again.\"\n    Exit 2\n}\n\n#Credential Object\n[pscredential]$credential= New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"$applicationId\",(\"$apiKey\" | ConvertTo-SecureString -AsPlainText -Force) \n\n#Connect to Azure\n$connect = Connect-AzAccount -Credential $credential -Subscription $subscriptionId -Tenant $tenantId -ServicePrincipal -Confirm:$false\nif($connect){\n    Write-Debug \"Connected to $($connect[0].Context.Environment.name)\"\n}\n\n#Get Snapshot Data\n$snapshotData = Get-AzSnapshot -ResourceGroupName $resourceGroup\n$validSnapshots = @()\nforeach ($snapshot in $snapshotData) {\n    Write-Host \"Looping through snapshot\" $snapshot.Name\n    if ($snapshot.Tags.Count -gt 0 -and $snapshot.Tags.Keys -contains \"CommanderRequestID\" -and $snapshot.Tags.Values -contains $requestId) {\n        Write-Host \"Snapshot found\"\n        $validSnapshots += $snapshot\n    }\n}\n\nif (!$validSnapshots) {\n    Write-Error \"No Snapshot found for request $requestId\"\n    Exit 3\n}\n\n#Get-VMdata\nTry{\n    Write-Host \"Getting VM data\"\n    $vmName = $instanceId.Split('/') | select -Last 1\n    $vmData = Get-AzVM -Name $vmName -ResourceGroupName $resourceGroup\n    $location = $vmData.Location\n    $osType = $vmData.StorageProfile.OsDisk.OsType    \n    $oldDisks = @($vmData.StorageProfile.OsDisk.Name)\n    Write-Host \"Adding disk $($oldDisks[0]) to the old list\"\n    foreach ($disk in $vmData.StorageProfile.DataDisks) {        \n        $oldDisks += @($disk.Name)\n        Write-Host \"Adding disk $($oldDisks[1]) to the old list\"\n        Remove-AzVMDataDisk -VM $vmData -Name $disk.Name\n        Sleep -Seconds 5\n    }\n}\nCatch{\n    $exception = \"$_.\"\n    Write-Error $exception\n    Exit 3     \n}\n\n#Stop VM\nWrite-Host \"Stopping VM\"\nStop-AzVM -ResourceGroupName $resourceGroup -Name $vmData.Name -Force\n\n# Create the new disk that you want to swap in\nfor ($i=0; $i -lt $snapshotData.Length; $i++) {\n    $diskType = \"_DataDisk$($i)_\"\n    if ($snapshotData[$i].OsType -ne $null) {\n        $diskType = \"_OsDisk_\"\n    }\n    $newDiskName = $($vmName + $diskType + ($snapshotData[$i].UniqueId.Split('-') | select -First 1))\n    Write-Host \"Creating disk $newDiskName\"\n    $diskConfig = New-AzDiskConfig  -Location $location -CreateOption Copy -SourceResourceId $snapshotData[$i].Id\n    $newDisk = New-AzDisk -DiskName $newDiskName -Disk $diskConfig -ResourceGroupName $resourceGroup\n    \n    if ($snapshotData[$i].OsType -ne $null) {\n        Write-Host \"$newDiskName is an OS disk\"\n        Set-AzVMOSDisk -VM $vmData -ManagedDiskId $newDisk.Id -Name $newDisk.Name \n    }\n    else {\n        Write-Host \"$newDiskName is a data disk\"\n        Add-AzVMDataDisk -VM $vmData -Name $newDisk.Name -Lun $i -CreateOption Attach -ManagedDiskId $newDisk.Id\n    }   \n    Update-AzVM -ResourceGroupName $resourceGroup -VM $vmData \n}\n\n#Remove old disks\nforeach ($disk in $oldDisks) {\n    Write-Host \"Deleting disk\" $disk\n    Remove-AzDisk -ResourceGroupName $resourceGroup -DiskName $disk -Force\n}\n\nStart-AzVM -ResourceGroupName $resourceGroup -Name $vmData.Name -Force",
        "script_arguments": "",
        "timeout": 300,
        "executable": "powershell.exe",
        "capture_output": true
      }
    }
  ]
}

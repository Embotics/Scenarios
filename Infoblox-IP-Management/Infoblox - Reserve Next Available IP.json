{
  "id" : 1,
  "guid" : "14ed8664-463b-4698-ae11-5187cea5e394",
  "name" : "Infoblox - Reserve Next Available IP",
  "description" : null,
  "type" : "APPROVAL",
  "change_description" : null,
  "target_type" : null,
  "input_variables" : [ {
    "name" : "Infoblox Credentials File Path",
    "variable" : "infobloxs_cred",
    "description" : null,
    "required" : true,
    "default_value" : null
  }, {
    "name" : "Infoblox WAPI Version",
    "variable" : "infoblox_wapi_version",
    "description" : null,
    "required" : true,
    "default_value" : "v2.6.1"
  }, {
    "name" : "vCommander Credentials File Path",
    "variable" : "vCommander_cred",
    "description" : null,
    "required" : true,
    "default_value" : null
  }, {
    "name" : "Infoblox URL",
    "variable" : "infoblox_url",
    "description" : null,
    "required" : true,
    "default_value" : null
  } ],
  "info_messages" : [ ],
  "system_version" : "7.1.6 (1007030241)",
  "steps" : [ {
    "name" : "Reserve IP",
    "type" : "EMBEDDED_SCRIPT",
    "condition" : null,
    "data" : {
      "credentials" : null,
      "failure_action" : "FAIL_STEP",
      "script_contents" : "<#\nDescription: Script that Calls out to IPAM to get the next available IP address for the VM in the request based on the Service Type Attribute on the request form in vCommander.\nRequirements: \n-VComamnder 7.0.2 or higher\n-Powershell V4 or greater\n-InfoBlox 8.1.2 or greater\n\nNote:\nYour Environment maye require additional or diffrent logic depending on how infoblox has been configured. This Example assumes the virtual Portgroup Name matches the subnet Description in infoblox. \n#>\n\n########################################################################################################################\n# Configure the variables below using the Production vCommander\n########################################################################################################################\n    #infoblox Info\n    $infobloxURL = \"#{inputVariable['infoblox_url']}\"   #infoblox Base URL\n    $infoBloxCred = \"#{inputVariable['infobloxs_cred']}\"     # Encrypted Credfile for Infoblox    \n    #vCommander Info\n    $vCredFile = \"#{inputVariable['vCommander_cred']}\"           #Encrypted Credfile for vCommander\n    $vCommanderURL = \"https://localhost\"                    #VCommander URL    \n    $ServiceType = \"#{request.services[1].settings.customAttribute['Service Type']}\"\n    $RequestID = \"#{request.id}\"\n\n    #Get the latest WAPI version for calls to Infoblox API\n    $WAPIVersion = \"#{inputVariable['infoblox_wapi_version']}\"\n\n########################################################################################################################\n# Nothing to configure below this line - Starting the main function of the script\n########################################################################################################################\n#Load vCommander Modules\n########################################################################################################################\n        Write-Host \"Loading Modules\"\n        $moduleName = \"VCommander\"\n        If (-not (Get-Module -name $moduleName)) {Import-Module -Name $moduleName \n        } else {Remove-Module $moduleName\n                        Import-Module -Name $moduleName }\n\n########################################################################################################################\n# Setting Cert Policy - required for successful auth with the infoblox API if infoblox is unsigned\n########################################################################################################################\nadd-type @\"\n    using System.Net;\n    using System.Security.Cryptography.X509Certificates;\n    public class TrustAllCertsPolicy : ICertificatePolicy {\n        public bool CheckValidationResult(\n            ServicePoint srvPoint, X509Certificate certificate,\n            WebRequest request, int certificateProblem) {\n            return true;\n        }\n    }\n\"@\n[System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy\n[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12;\n\n#Setup Auth to Infoblox\n    $iCred = New-DecryptCredential $infoBloxCred\n    $authInfo = (\"{0}:{1}\" -f $iCred.GetNetworkCredential().userName,$iCred.GetNetworkCredential().Password)\n    $authInfo = [System.Text.Encoding]::UTF8.GetBytes($authInfo)\n    $authInfo = [System.Convert]::ToBase64String($authInfo)\n    $infobloxsessionHeader = @{Authorization=(\"Basic {0}\" -f $authInfo)}\n    $contentType = \"application/json\"\n\n#Get All Networks from Infoblox\n    $NetworksURL =  $infobloxURL +\"/wapi/$WAPIVersion/network?comment~:=$ServiceType&_return_fields=comment,ipv4addr,netmask,network,network_view,options\"\n    Try\n\t{\n\t\t$NetworksJson = Invoke-WebRequest -Uri $NetworksURL -Headers $infobloxsessionHeader -Method GET -ContentType $contentType\n\t\t$NetworkData = ConvertFrom-Json -InputObject $NetworksJson\n\t}Catch {\n\t\tWrite-Host \"Failed to Authenticate to get Networks from Ipam\" -ForegroundColor Red\n\t\t$error[0] | Format-List -Force\n\t\tExit 1\n\t}  \n\n#Get the Network Details\n    foreach($elm in $NetworkData.options)\n\t{\n\t\tif($elm.name -eq \"routers\")\n        {\n            $Gateway = $elm.value\n        }\n\n        if($elm.name -eq \"domain-name-servers\")\n        {\n            $addresses = $elm.value.Split(\",\")\n\n            if($addresses.count  -gt 0 -And $addresses[0] -ne $null)\n            {\n                $dns_primary = $addresses[0]\n            }\n            if($addresses.count -gt 1)\n            {\n                $dns_secondary = $addresses[1]\n            }\n        }\n\n        if($elm.name -eq \"domain-name\")\n        {\n            $domainName = $elm.value\n        }\n\t}\n\n\t\n\t$infobloxNetmask = $NetworkData.network\n\n    switch ($NetworkData.netmask) \n    { \n        1 {$vCommanderNetmask = \"128.0.0.0\"} \n        2 {$vCommanderNetmask = \"192.0.0.0\"}\n        3 {$vCommanderNetmask = \"224.0.0.0\"}\n        4 {$vCommanderNetmask = \"240.0.0.0\"}\n        5 {$vCommanderNetmask = \"248.0.0.0\"}\n        6 {$vCommanderNetmask = \"252.0.0.0\"}\n        7 {$vCommanderNetmask = \"254.0.0.0\"}\n        8 {$vCommanderNetmask = \"255.0.0.0\"}\n        9 {$vCommanderNetmask = \"255.0.0.0\"}\n        10 {$vCommanderNetmask = \"255.192.0.0\"}\n        11 {$vCommanderNetmask = \"255.224.0.0\"}\n        12 {$vCommanderNetmask = \"255.240.0.0\"}\n        13 {$vCommanderNetmask = \"255.248.0.0\"}\n        14 {$vCommanderNetmask = \"255.252.0.0\"}\n        15 {$vCommanderNetmask = \"255.254.0.0\"}\n        16 {$vCommanderNetmask = \"255.255.0.0\"}\n        17 {$vCommanderNetmask = \"255.255.128.0\"}\n        18 {$vCommanderNetmask = \"255.255.192.0\"}\n        19 {$vCommanderNetmask = \"255.255.224.0\"}\n        20 {$vCommanderNetmask = \"255.255.240.0\"}\n        21 {$vCommanderNetmask = \"255.255.248.0\"}\n        22 {$vCommanderNetmask = \"255.255.252.0\"}\n        23 {$vCommanderNetmask = \"255.255.254.0\"}\n        24 {$vCommanderNetmask = \"255.255.255.0\"}\n        25 {$vCommanderNetmask = \"255.255.255.128\"}\n        26 {$vCommanderNetmask = \"255.255.255.192\"}\n        27 {$vCommanderNetmask = \"255.255.255.224\"}\n        28 {$vCommanderNetmask = \"255.255.255.240\"}\n        29 {$vCommanderNetmask = \"255.255.255.248\"}\n        30 {$vCommanderNetmask = \"255.255.255.252\"}\n        31 {$vCommanderNetmask = \"255.255.255.254\"}\n        32 {$vCommanderNetmask = \"255.255.255.255\"}\n\n        default {Write-Host \"The netmask is invalid\" Exit 1}\n\n    }\n        \n\n#Setup Auth to Vcommander\n    $vCred = New-DecryptCredential $vCredfile\n\n#Get Service request Information from request\n    Try{$serviceRequestsendpoint = \"/rest/v3/service-requests\"\n        $RequestidURL = $vCommanderURL+$serviceRequestsendpoint+'/'+$requestId\n        $convertedJson = Invoke-RestMethod $RequestidURL -Credential $vCred\n        $Requester = $convertedJson.summary.submitted_by\n        }Catch {Write-Host \"Failed to get requester information from vCommander\" -ForegroundColor Red\n                $error[0] | Format-List -Force\n                Exit 1\n                }\n\n#Service requests\n    Try{$serviceRequests = $convertedJson.services\n        $ServicesURL = $vCommanderURL+'/rest/v3/services'\n        $Services = Invoke-WebRequest -contentType \"application/json\" -Uri $ServicesURL -Method GET -Credential $vCred\n        $AllServices = ($services |ConvertFrom-Json).items\n         }\n         Catch {Write-Host \"Failed to Get vCommander Services\" -ForegroundColor Red\n                $error[0] | Format-List -Force\n                Exit 1\n                }\n\n#Iterate through the Request and set IP address information\n    foreach ($service in $serviceRequests) {\n            $serviceName = $service.service.name\n            $ServiceID = ($AllServices | Select-Object id,name  | Where-Object {$_.name -eq $serviceName}).id\n            $components = $service.components.name\n            foreach ($component in $components) \n            {\n                $componentName = $component\n                $PostParamsURL = $vCommanderURL+'/rest/v3/service-requests/'+$RequestId+'/services/'+$serviceName+'/components/'+$componentName+'/deployment-parameters'\n                \n                $date1 = Get-Date -Date \"01/01/1970\"\n                $date2 = Get-Date                \n                $DateValue = (New-TimeSpan -Start $date1 -End $date2).TotalSeconds\n\n                $JSONbody = \n                    \"{\n\t                  \"\"name\"\": \"\"$DateValue.reserved.$domainName\"\",\n\t                  \"\"ipv4addrs\"\": [\n\t\t                {\n\t\t                  \"\"ipv4addr\"\": \"\"func:nextavailableip:$infobloxNetmask\"\"\n\t\t                }\n\t                  ]\n\t                }\"\n\n            #Perform POST Request to attach the next available IP from infoblox\n                $nextFreeURL = $infobloxURL +\"/wapi/$WAPIVersion/record:host\"\n                $nextfreeRequest = Invoke-WebRequest -Uri $nextFreeURL -Headers $infobloxsessionHeader -Body $JSONbody -Method POST -ContentType $contentType\nwrite-host                 $nextfreeRequest\n                if($nextfreeRequest.StatusDescription -eq 'Created'){\n                     Write-host $nextfreeRequest.StatusDescription}\n                elseif($nextfreeRequest.StatusDescription -ne 'Created')\n                      {Write-host \"Failed to Get next IP from IPAM\" -ForegroundColor Red\n                       Exit;1}\n                 \n            #Get the IP addres value\n            $addressGETURL = $infobloxURL + \"/wapi/$WAPIVersion/\" + $nextfreeRequest.Content.Substring(1,$nextfreeRequest.Content.Length - 2)\n            $ipGETResponse = Invoke-WebRequest -Uri $addressGETURL -Headers $infobloxsessionHeader -Method GET -ContentType $contentType\n\n            $nextFreeIP = ($ipGETResponse.Content |ConvertFrom-Json).ipv4addrs.ipv4addr\n\n\n            #Setup Json param body to post to the service\n$postBody = @\"\n    {\n        \"nics\": [\n                    {\n                        \"ip\": \"$nextFreeIP\",\n                        \"netmask\": \"$vCommanderNetmask\",\n                        \"gateway\": \"$Gateway\",\n                        \"dns_primary\": \"$dns_primary\",\n                        \"dns_secondary\": \"$dns_secondary\",\n                        \"network\": \"$ServiceType\"\n                    }\n            ]\n        }\n\"@\n            #  Write-Host $postBody\n            Try\n            {\n                $postJSON = Invoke-WebRequest -contentType \"application/json\" -Uri $PostParamsURL -Method POST -Body $postBody -Credential $vCred\n            }\n            Catch \n            {\n                Write-Host \"Failed to post deployment parameters to vCommander\" -ForegroundColor Red\n                $error[0] | Format-List -Force\n                Exit 1\n            }\n           }   \n        }",
      "script_arguments" : "",
      "timeout" : 300,
      "executable" : "powershell.exe",
      "capture_output" : true
    }
  } ]
}